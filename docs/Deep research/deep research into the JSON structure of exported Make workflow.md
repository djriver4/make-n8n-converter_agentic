I'll conduct deep research into the JSON structure of exported Make.com workflows, covering:

- **Overall JSON Schema**: The general structure, key-value elements, and how workflows are organized in JSON format.
- **Modules and Connections**: How different modules are represented, how they interact, and how data flows between them.
- **Example Exported Workflows**: Real-world examples of exported JSON files to illustrate their format and usage.
- **Modifying or Generating JSON**: How users can manually edit or generate JSON files to customize workflows.
- **Dependencies and Authentication**: How authentication, API keys, and dependencies are stored and referenced in the JSON file.

I'll let you know when I have the findings ready.

## Overall JSON Schema Structure  
Exported Make.com workflows (blueprint files) are saved as JSON and capture the entire scenario configuration – including all modules, connections, filters, and actions ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=,modules%2C%20connections%2C%20filters%2C%20and%20actions)). The JSON is hierarchical, typically starting with some top-level metadata (like the scenario name) and then the workflow definition. At the core is an array of modules (often under a key like `"flow"` or `"subflows"` if multiple parallel flows exist). Each module in the workflow is represented as a JSON object with its own properties, and modules can be nested if there are routers or branches. For example, an exported blueprint might begin like this, showing the scenario name and the first module in a flow:  

```json
{
  "name": "Daily Digest",
  "flow": [
    {
      "id": 12,
      "module": "builtin:BasicRouter",
      "version": 1,
      "mapper": null,
      "metadata": { … }
      /* ... */
    }
    /* additional modules ... */
  ]
  /* ... */
}
``` ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=%7B%20,))

In this structure, `"flow"` is an array of module objects defining the scenario’s steps. If a scenario has multiple independent trigger paths, the JSON may use a `"subflows"` array, where each entry contains its own `"flow"` representing one path. Modules like routers can introduce nested flows as well – for instance, a **Router** module in the JSON will have a `"routes"` key containing an array of route objects, each with its own `"flow"` sub-array of modules ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,1)). This hierarchical nesting allows the JSON to represent branches, loops, and error handlers. Overall, the JSON schema is organized such that the scenario (or “blueprint”) is the root, which contains one or more flows of modules, and each module may further contain sub-structures (for routes, iterations, etc.) as needed.

**Key top-level elements** often include:  

- **Scenario Metadata**: e.g. `"name"` (scenario name) and possibly `"metadata"` for scenario-level settings. For example, the blueprint’s metadata might store settings like maximum errors, execution mode, etc. ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,false)). These control runtime behavior (e.g. parallel vs sequential processing, error handling limits) but do not contain the logic of the modules themselves.  
- **Flows/Subflows**: the array that holds the ordered list of modules (or multiple such arrays for separate triggers). In a simple scenario, you’ll see a single `"flow"` array. In complex scenarios with multiple starting points, the JSON may wrap them in a `"subflows"` list (each with its own `"flow"`). Within these flows, the execution order generally follows the array order (unless modified by routers or other control modules).  
- **Nested Structures**: Certain module types (like routers or iterators) contain nested flows. For example, a router module object will include a `"routes"` field that contains an array of route definitions, each with its own `"flow"` array of modules that execute in that branch ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,1)). Similarly, error handler branches (if defined) might appear under an `"errorRoute"` or similar key attached to a module. This nested JSON structure mirrors the visual scenario structure in Make’s editor.  

Overall, the JSON blueprint is a faithful representation of the scenario’s graph: parent-child relationships in the JSON indicate structural containment (like routers containing route modules), and sequential ordering (or explicit references) indicate the connections between steps.

## Representation of Modules and Connections  
Each **module** in a Make.com scenario is represented as a JSON object with several key properties describing its function and configuration. Important fields in a module’s JSON object include:  

- **`id`**: A unique numeric identifier for the module within the scenario. This ID is used to reference the module (for example, in mappings or in aggregator settings).  
- **`module`**: A string identifier for the module type, usually in the format `"app:operation"` or `"app:trigger"`. For instance, `"weather:ActionGetDailyForecast"` indicates a Weather app module performing the “Get Daily Forecast” action, and `"microsoft-teams:watchMessages1"` would indicate a Microsoft Teams *Watch Messages* trigger ([Scenario Blueprint JSON string - Text Parser Replace RegEx - How To - Make Community](https://community.make.com/t/scenario-blueprint-json-string-text-parser-replace-regex/4169#:~:text=%7B%5C%22flow%5C%22%3A%5B%7B%5C%22id%5C%22%3A11%2C%5C%22mapper%5C%22%3A%7B%7D%2C%5C%22module%5C%22%3A%5C%22microsoft,team)). Triggers are not distinguished by a special field – they are simply the first module(s) in the flow (e.g. a webhook or schedule trigger module appears as a module with a specific `module` name like `"webhooks:customWebhook"`).  
- **`version`**: The version of the app/module. This helps Make identify which version of the connector or operation to use.  
- **`parameters`**: An object containing configuration settings or credentials for the module. These are usually the fields that are not mappings from previous modules but rather fixed settings. For example, a module that connects to an external service might have an `account` or connection reference here. In the JSON, **authentication** is handled by reference: instead of an actual API key, the module will store an account ID or connection ID. For instance, a Google Calendar module might have `"parameters": { "account": 1282607, "continueWhenNoRes": true }` ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,setMinute%28setHour%28now%3B%2023%29%3B%2059)), where `account: 1282607` is an internal reference to a saved Google account connection. (In other cases, you might see a field like `"__IMTCONN__"` with a numeric ID – this is a similar placeholder for a connection credential ([Scenario Blueprint JSON string - Text Parser Replace RegEx - How To - Make Community](https://community.make.com/t/scenario-blueprint-json-string-text-parser-replace-regex/4169#:~:text=nel%5C%22%2C%5C%22type%5C%22%3A%5C%22any%5C%22%2C%5C%22label%5C%22%3A%5C%22Channel%20ID%5C%22%2C%5C%22required%5C%22%3Atrue%7D%5D%7D%2C%5C%22parameter%20s%5C%22%3A%7B%5C%22team%5C%22%3A%5C%2200000000)).) These IDs map to credentials in the user’s Make account and ensure sensitive keys are not stored in plain text in the blueprint.  

- **`mapper`**: An object that defines how data flows into the module’s input fields. This is essentially the mapping of outputs from previous modules or static values into the module’s expected inputs. Each key in `mapper` corresponds to an input field name, and the value can be a static value, a formula, or a reference to another module’s output. Make’s runtime formulas and mappings (often using the `{{ ... }}` syntax) appear here as strings. For example, a module that formats text might have a mapper like:  
  ```json
  "mapper": {
    "value": "Temperature is {{1.temperature}} and conditions are {{7.output}}"
  }
  ```  
  This indicates the module’s `value` input is being composed from module **1**’s `temperature` output and module **7**’s `output` value ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,round%281.wind.speed%29%7D%7D%20%D0%BC%2F%D1%81)). The numbers (`1`, `7`) refer to the `id` of the source module, establishing a data dependency. In essence, the `mapper` section is where **data mapping** between modules is declared in JSON, using those module IDs and templating to pull in data. (If a field expects a list or complex structure, the mapper might contain arrays or nested objects accordingly. For instance, selecting multiple items might show up as an array of values in the mapper.)  

- **`filter`** (optional): If a connection between two modules has a filter (a conditional rule that determines whether the target module executes), the target module’s JSON will include a `"filter"` object. The filter object contains a name and a set of conditions. Conditions are typically represented as an array of groups, where each group is an array of condition objects. Each condition object has fields like `"a"` (the left operand, often a reference to a data element), `"b"` (the right operand or value to compare against), and `"o"` (the operator, e.g. `text:equal`, `number:greater`, etc.) ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=%7B%20,%7D%20%5D%2C%20%5B)). For example, a filter named “Only my events” might appear as:  

  ```json
  "filter": {
    "name": "Only my events",
    "conditions": [
      [
        { "a": "{{8.creator.email}}", "b": "you@example.com", "o": "text:equal" }
      ]
    ]
  }
  ``` ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,))

  This indicates that the module should only execute if the creator’s email from module 8 equals `"you@example.com"`. Multiple condition objects in one inner array would be combined with AND logic, and multiple inner arrays in `"conditions"` represent OR logic between groups.  

- **`metadata`**: An object containing additional information about the module, often used by Make’s editor. It can include:  
  - **Designer info** – e.g. `"designer": { "x": -159, "y": -278, "name": "Format calendar event" }` which stores the module’s position on the canvas and an optional custom name/label ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,value)). This has no effect on execution, but it preserves how the scenario was laid out visually and any custom naming of modules.  
  - **Expected schema (`expect`)** – an array describing the input fields for this module, their types, labels, and requirements ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,Use%20regular%20expressions%20to%20match)) ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=%7B%20,%7D%2C)). Each object in this array corresponds to one configurable input for the module (the same fields that might appear in the module’s configuration dialog in the UI). For example, it might list that a field “City” is of type text and required, etc. This helps the Make interface know how to present the module’s settings if the blueprint is imported.  
  - **Restore info** – sometimes present to store the last used choices or cached options for dropdown fields. For instance, `"restore"` might hold the last selected labels or IDs for certain dynamic fields (like the chosen spreadsheet name, etc.) so that the UI can display it correctly ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=%E2%80%9Crestore%E2%80%9D%3A%20,%E2%80%9CsheetId%E2%80%9D%3A)) ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=%7D%2C%20%E2%80%9CspreadsheetId%E2%80%9D%3A%20,%E2%80%9Clabel%E2%80%9D%3A%20%E2%80%9CYes%E2%80%9D%2C%20%E2%80%9Cnested%E2%80%9D%3A)). This section often contains IDs or names that were fetched when the scenario was built (e.g. selected drive or sheet names in a Google Sheets module) and are mostly for convenience in re-editing the scenario.  
  - **Interface/Output schema** – some modules include an `"interface"` section listing their output data structure (similar to `expect` but for outputs). For example, a JSON aggregator or variable setter might define what output variable it provides so that downstream modules can reference it.  

- **Connection/Route keys**: In some modules, you’ll see special fields that define how modules connect. For example, a **Router** (like the built-in router or tools like the Iterator) will have a property like `"routes"` (for routers) or other route keys. In the JSON, a router module’s entry would include `"routes": [...]` containing multiple flows. Each route is essentially a sub-flow (an object with its own `"flow"` array of modules) that branches off ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,1)). This is how the JSON represents parallel branches: the router module encapsulates them. Another example is the **Iterator/Aggregator** modules: these often reference other module IDs in their parameters to indicate which module’s output they are iterating or aggregating. In the JSON above, a Text Aggregator module has `"parameters": { "feeder": 8, ... }` to indicate it feeds on the output bundles of module **8** ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,)). Similarly, an Iterator might have a target collection or array field coming from a previous module referenced by ID.  

**Data flow between modules** is thus represented in two ways: implicitly by the structure/order of modules in a flow, and explicitly by references (module IDs in mappings or special parameters). In a simple linear flow, the JSON list order usually reflects the execution order (the first module is typically the trigger, followed by subsequent actions). But more concretely, whenever module B needs data from module A, that relationship is captured by using A’s `id` in B’s mapper or parameters. For instance, if module 2 uses output from module 1, you’ll see `{{1.someField}}` inside module 2’s `mapper` fields ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=%E2%80%9Cvalues%E2%80%9D%3A%20,Basics%E2%80%9D%2C%20%E2%80%9CspreadsheetId%E2%80%9D%3A%20%E2%80%9C%2F%E2%80%9D%2C%20%E2%80%9CincludesHeaders%E2%80%9D%3A%20true)). If a module is not supposed to run unless certain conditions from a prior module are true, a `filter` on that module encodes the dependency on the prior module’s outputs ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,)). And for modules that combine or split data, dedicated fields like `"feeder": <id>` (in aggregators) or nested route structures (in routers) define those connections. There isn’t a separate list of connections in the JSON; instead, connections are inherently defined by these references and the nested placement of modules under router/iterator modules. In summary, **triggers** appear as the first module(s) in the flow, **actions/transformers** follow with `mapper` references to previous modules’ data, **filters** are inline as conditions on modules, and **branching or looping** is represented by nested flow structures or special parameters referencing module IDs.

## Example Exported Workflow JSON  
To illustrate the above, let’s walk through a simplified example of an exported Make.com scenario in JSON form. Consider a scenario that fetches weather data and then adds a row to a Google Sheet – two modules in sequence. The exported JSON (blueprint) might look like this (with most metadata removed for clarity):  

```json
{
  "name": "Weather to Sheet",
  "flow": [
    {
      "id": 1,
      "module": "weather:ActionGetCurrentWeather",
      "version": 1,
      "parameters": {},
      "mapper": {
        "city": "London, UK",
        "type": "name"
      },
      "metadata": { … }
    },
    {
      "id": 22,
      "module": "google-sheets:addRow",
      "version": 2,
      "parameters": {
        "IMTCONN": 821060
      },
      "mapper": {
        "from": "drive",
        "mode": "select",
        "values": {
          "0": "{{1.sunrise}}",
          "1": "{{1.temperature}}",
          "2": "{{1.name}}",
          "3": "{{1.description}}"
        },
        "sheetId": "Make Basics",
        "spreadsheetId": "/",
        "includesHeaders": true,
        /* ...other settings... */
      },
      "metadata": { … }
    }
  ]
}
```  

In this example, the first module (ID 1) is a Weather module that takes a city name (`"London, UK"`) as input ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=,%E2%80%9CLondon%2C%20UK%E2%80%9D%2C%20%E2%80%9Ctype%E2%80%9D%3A%20%E2%80%9Cname%E2%80%9D)). The second module (ID 22) is a Google Sheets module to add a row. In its `parameters`, we see `"IMTCONN": 821060` – this is the reference to the Google Sheets connection (an account ID) so the module knows which Google account to use ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=%E2%80%9Cparameters%E2%80%9D%3A%20,1.temperature%7D%7D%E2%80%9D)). Its `mapper` shows how it takes data from module 1: the `values` object maps columns 0,1,2,3 of the new row to outputs from module 1 (`sunrise`, `temperature`, `name` (city name), `description` (weather description) respectively) ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=%E2%80%9Cvalues%E2%80%9D%3A%20,Basics%E2%80%9D%2C%20%E2%80%9CspreadsheetId%E2%80%9D%3A%20%E2%80%9C%2F%E2%80%9D%2C%20%E2%80%9CincludesHeaders%E2%80%9D%3A%20true)). The string `{{1.sunrise}}` means “take the `sunrise` output from module with id 1.” This is how the JSON links module 1’s output to module 22’s inputs. Other fields in the mapper (`from`, `mode`, `sheetId`, etc.) are configuration telling the Sheets module which spreadsheet and sheet to use, whether the first row is headers, etc., just as you’d configure in the Make UI. All of these appear as JSON fields in the blueprint. 

This simple example lacks a filter or branching, so every execution of module 1 will pass directly into module 22. If we had a filter between them (say we only add a row if the temperature is above a threshold), module 22’s JSON would include a `"filter"` section as described earlier. If we introduced a router (for example, to do something else in parallel with logging the weather), the JSON might include a router module and separate flows under `"routes"`. The blueprint format scales to complex scenarios. For instance, a more complex real-world JSON might include a **router** as the first module (to branch into two parallel flows), one branch fetching weather and storing it, another branch fetching calendar events, and later an aggregator merging both branches’ data. In JSON, that scenario’s blueprint shows the router (with nested flows for each branch), modules referencing each other’s IDs (one branch storing a variable and the other branch retrieving it), and an aggregator with a `feeder` pointing to the module that produced the collection of events ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,)). Each module’s role is discernible from fields like `module` (which tells what it does) and the presence of any filter or special parameters. Real exported JSON files can be lengthy, but they follow this structured pattern: module entries in order, nested as needed, each with clear fields for IDs, types, parameters, and mappings. 

**Understanding Fields in Context:** Take the JSON snippet below from a more complex blueprint – it shows part of a flow where a filter is applied and an aggregator is used:  

```json
{
  "id": 10,
  "module": "util:ComposeTransformer",
  "version": 1,
  "filter": {
    "name": "Only my events",
    "conditions": [
      [
        { "a": "{{8.creator.email}}", "b": "you@example.com", "o": "text:equal" }
      ]
    ]
  },
  "mapper": {
    "value": "{{formatDate(8.start; \"HH:mm\")}}–{{formatDate(8.end; \"HH:mm\")}} [{{8.summary}}]({{8.htmlLink}})"
  },
  "metadata": { … }
},
{
  "id": 16,
  "module": "util:TextAggregator",
  "version": 1,
  "parameters": {
    "feeder": 8,
    "rowSeparator": "\n"
  },
  "mapper": { "value": "{{10.value}}" },
  "metadata": { … }
}
```  

In this excerpt, module **10** is a *Compose Text* module that formats a calendar event into text. It has a `filter` named "Only my events" with a condition: it only runs if the creator’s email from module 8 equals “you@example.com” ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,)). The `mapper.value` for module 10 constructs a string using outputs from module **8** (start time, end time, summary, link), showing how data from the Google Calendar event (module 8) is mapped into a text format. Module **16** is a *Text Aggregator* which collects all the texts from module 10 across multiple bundles. Its `parameters` include `"feeder": 8` meaning it’s aggregating over all outputs of module 8 (i.e. all calendar events) ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,)). The aggregator’s `mapper.value` takes `{{10.value}}`, i.e. the formatted text from module 10, to build the aggregated result. This demonstrates how connections between modules appear in JSON: module 10’s filter conditions reference module 8’s output fields, and module 16 explicitly references module 8 as its feeder and module 10 for the value to aggregate. These JSON links mirror the scenario logic: *module 10 is only executed for certain events from 8, and module 16 waits for module 8’s events and aggregates the outputs of 10.* 

In a full exported JSON file, you would also find closing sections with scenario-level settings (as shown earlier), but the core of the file is essentially a list of modules with these kinds of fields. Reading an exported workflow JSON, while initially intimidating, becomes easier once you recognize this pattern of module objects and how they reference each other.

## Modifying or Generating Workflow JSON  
Because Make blueprints are just JSON, advanced users can **edit or even generate these JSON structures manually** – but it must be done carefully. In essence, you can open the exported `.json` in a text editor and tweak modules, add new ones, change mappings, etc. Make even allows importing blueprints by pasting JSON text directly into the scenario builder ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=Down%20on%20the%20bottom%20of,three%20dots%2C%20then%20Import%20Blueprint)) ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=Try%20pasting%20this%20text%20directly,and%20see%20if%20it%20works)), which means you can take a JSON blueprint snippet and create a scenario from it. Here are some guidelines and considerations for modifying/generating Make workflow JSON:  

- **Adhere to the Schema**: All keys, nesting, and values must follow the expected format. If you manually add a module, ensure it has all necessary fields (`id`, `module`, `version`, `mapper`, `parameters`, `metadata`, etc.) and that its inputs/outputs are defined in `metadata.expect/interface` properly. It’s often easiest to copy an existing module’s JSON structure and adjust it, rather than writing one from scratch, to avoid missing fields. Using a JSON schema or a linter can help validate the structure. (Make doesn’t publicly provide a full JSON schema, but the pattern from exported blueprints can serve as an implicit schema.)  

- **Unique IDs and References**: Every module `id` should be unique within the scenario. If you duplicate a module section, make sure to give it a new `id` and update any references to it. Conversely, if you change a module’s id, you must update all mappings or feeders that pointed to it. In the JSON, references between modules are by these numeric IDs, so consistency is crucial. For example, if module 5’s output was used elsewhere as `{{5.field}}`, and you renumber module 5 to 6, you’d have to find all `{{5.` references and change them to `{{6.` as well. A failure to update a reference will mean the scenario tries to point to a non-existent module.  

- **Use Find & Replace for Bulk Edits**: One practical tip for editing is using find-and-replace for known strings. The Make blueprint JSON is a text file, so you can change occurrences of certain module names or identifiers. For instance, if you have a custom app or a specific connection that you want to swap out (perhaps to switch the scenario from a production app to a testing app), you can find the app’s identifier string or connection ID in the JSON and replace it with the new one ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=Note%3A%20If%20you%20have%20custom,to%20manually%20update%20each%20module)). However, do this with caution – ensure you’re not accidentally replacing something unintended, and always double-check the JSON is still valid after replacements.  

- **Maintain Proper Nesting**: When adding or moving modules, be careful about the nested structure. For example, if you manually add a module that should be inside a router branch, it needs to go within that router’s `"routes"` -> `"flow"` array in the JSON. Placing it at the wrong level (e.g., in the top-level flow when it was supposed to be in a route) could break the logic or cause the import to fail. Keep track of curly braces and brackets to preserve the hierarchy.  

- **Leverage the Make API for advanced use cases**: Instead of purely manual editing, some users script blueprint modifications using the Make API. The API endpoint `GET /v2/scenarios/<id>/blueprint` returns the scenario JSON, which can then be programmatically modified and sent to `POST /v2/scenarios` to create a new scenario. This allows for dynamic generation of scenarios. For example, one might fetch a blueprint, alter some module parameters via code (ensuring to escape characters properly), and import the updated blueprint automatically ([How to put together blueprints to run a scenario with API - How To - Make Community](https://community.make.com/t/how-to-put-together-blueprints-to-run-a-scenario-with-api/3196#:~:text=I%20have%20a%20scenario%20that,and%20hard%20to%20maintain%2C%20but)). This is useful for bulk updates or cloning scenarios with slight differences. If doing this, remember to update all dependent fields consistently (as noted above). Also, be aware that Make’s interface might not accept a blueprint that has invalid IML (Integromat Markup Language) expressions or references to non-existent modules; ensure any formula references (`{{ ... }}`) still point to valid module IDs after your edits, or the import may error out or the scenario might not function correctly. 

- **Test and Validate**: After modifying a JSON, *always* test by importing it into Make (preferably in a test environment or sandbox team first). Make provides immediate feedback if the JSON isn’t well-formed or has invalid content – the import might fail or the scenario might load with errors. Upon import, review the scenario in the editor: check that all modules appear, connections are in place, and all settings came through. The visual layout might be jumbled if you added modules without designer coordinates (or you can quickly auto-arrange them), but focus on whether the logic is intact. Run the scenario with sample data if possible to ensure the workflow behaves as expected. Essentially, treat manual JSON edits as you would code changes: verify them thoroughly.  

- **Restrictions**: There are a few things you typically should not change manually. For instance, avoid altering the `"version"` numbers of modules unless you know a different version is required – these correspond to backend versions of the app connectors. Changing them arbitrarily could result in mismatched fields. Similarly, do not remove or rename fields in the `metadata.expect` array without good reason – those definitions are needed for the scenario to be editable. When generating JSON, also remember that some fields (like connection IDs or certain dynamic IDs in `"restore"`) are environment-specific; you might leave those as placeholders and let the user reconfigure in the UI after import, rather than trying to fabricate an ID that might not exist in another account.  

- **Potential Issues**: One common issue is missing credentials or connections after import. If you import a blueprint that references connection IDs which don’t exist in the target account, the scenario will import but those modules will show an error or prompt to reconnect. This isn’t exactly a “JSON error” but something to expect – the JSON might be perfectly valid, yet the scenario needs additional setup (like re-linking an API connection or entering an API key). Another potential pitfall is that certain modules (like HTTP requests or tools) might contain raw text of configurations (headers, payloads, etc.) – if you manually edited those, a syntax error there could break the module’s function. Always ensure any JSON inside the blueprint (for example, within an HTTP module’s payload mapping) remains properly escaped and formatted. Finally, note that the blueprint JSON format can evolve as Make updates its platform. A blueprint exported today might have slight differences in structure compared to one from a few years ago (for example, older Integromat exports might not have used the `"subflows"` container, whereas newer ones do). So, ensure any JSON you hand-craft matches the current expected format, and consider exporting a simple scenario yourself as a template.  

In summary, manual or programmatic editing of Make JSON blueprints is powerful for templating and automation, but it requires precision. It’s usually safest to make incremental changes and test often. Make’s own documentation encourages reviewing the JSON for correctness (modules, connections, logic) before re-importing ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=,Pay%20attention%20to)). If you follow the schema and keep references consistent, you can successfully modify and even generate complex workflows via JSON.

## Handling Dependencies and Authentication in JSON  
When dealing with exported workflow JSON, understanding how **external connections and inter-module dependencies** are represented is crucial, especially for security and portability:  

- **Authentication & API Connections**: Make.com scenarios often involve connections to external services (APIs, SaaS accounts, etc.). In the JSON blueprint, **credentials are never stored in plaintext** – instead, the blueprint references a credential by an internal ID or placeholder. We saw this in examples above: fields like `"IMTCONN": 821060` or `"account": 1282607` in the `parameters` object represent a link to a saved account connection in Make ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,setMinute%28setHour%28now%3B%2023%29%3B%2059)). Similarly, for OAuth-type connections or API keys configured in Make, the module might have a parameter for the connection (often named generically like `"connection"` or app-specific) with an ID value. These IDs are only meaningful within the original Make account where the blueprint was exported; they act as foreign keys pointing to stored auth credentials. 

  **Security Consideration**: Because of this design, an exported JSON does **not** expose your login credentials or API tokens – anyone importing the JSON would have to provide their own valid connection to use those modules. This is great for security (you can share a blueprint without sharing secrets), but it means after importing a blueprint, you must re-authenticate or reconnect modules to accounts in the new environment. The JSON file itself will still contain the old reference IDs, which won’t resolve in a different account. As noted in Make’s documentation, when you import a blueprint you should expect to configure the connectors (API keys, logins) again before running the scenario ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=,Connectors%20or%20Credentials)). In practice, upon import, the Make UI will show those modules as needing attention (e.g. “Not authorized” or similar) until you edit them and select an account/connection that exists in your account.  

- **Managing Credentials in JSON**: If you are manually editing a JSON to port a scenario to another environment (say from a dev team to a prod team), you might proactively replace the connection IDs in the JSON with ones from the target environment **if** you know them. For example, if in your production account the Google Sheets connection ID is different, you could find/replace the old ID with the new ID so that the scenario works immediately on import. This requires knowing the target ID (which you can get by exporting a small scenario that uses the same connection in the target account, or via the Make API). Otherwise, you’ll simply import and then use the UI to select the proper connection (which updates the scenario’s JSON in Make’s database to the correct ID). In any case, **never insert actual keys or passwords** directly into the JSON in places they don’t belong; always use the connection mechanism. The only time an API key might appear in JSON is if a module expects a raw key in a field (for example, using an HTTP module and putting a Bearer token in a header mapping). Those values, if present, would be visible in the JSON. Treat the JSON file as sensitive in those cases and consider removing or redacting any hardcoded secrets before sharing the blueprint.  

- **Inter-Module Dependencies**: Aside from auth, modules often depend on each other’s data. These dependencies are handled through the `id` references as discussed. One subtle aspect is **execution order and dependency**: Make will automatically resolve the order based on connections. For example, if module 5’s output is used in module 6, Make knows 5 must run before 6. In the JSON, module 6 might physically appear after 5 in the array (which is typical), but even if not, the reference ensures the logical dependency. This means when editing, you should maintain a logical ordering to avoid confusion – it’s wise to list modules in the order they execute. The `"orphans"` list in the scenario `metadata.designer` ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=%7D%2C%20,eu1.integromat.com)) will list any module IDs that aren’t connected to others (e.g. unlinked modules sitting on the canvas) – ideally, in a complete scenario, there are no orphans except maybe intentionally disabled parts. When generating JSON, ensure every module (except a trigger) has its inputs coming from somewhere (either a previous module or a constant in the mapper), otherwise it might be an orphan or a dead-end in the flow.  

- **Error Handling & Dependencies**: If your scenario has error handlers (the “Resume” or “Break” error routes in Make), those appear in JSON as additional route sections attached to modules. They depend on the module they handle. For example, a module might have an `"errorRoute"` key with a flow of modules to execute if that module fails. These are another form of dependency – they won’t run unless the parent module errors. When editing JSON, if you remove or renumber a module that has an error route, be sure to adjust or remove its error route accordingly. The blueprint must remain consistent (no dangling error routes referencing a non-existent module).  

- **External Services & Data Dependencies**: Some modules depend on external definitions or data models – for instance, a custom webhook might depend on a specific webhook ID or token (which might be in the JSON as part of the URL or an ID). Another example is a Data Store module which references a Data Store by ID. These IDs (like connection IDs) are environment-specific. If you export a scenario using a Data Store, the blueprint will contain the Data Store’s ID. If you import it to a new environment, that ID might not exist (unless you also migrated the Data Store). In such cases, you’d have to edit the module after import to point it to a valid resource in the new environment. The general rule is: **IDs that refer to external resources (accounts, webhook endpoints, data stores, etc.) usually need to be re-linked**. The JSON won’t magically bring those resources with it.  

- **Security of JSON Files**: Treat exported Make JSON files as you would source code. While they might not contain passwords, they can reveal aspects of your workflow logic and data (e.g. field names, sometimes sample data or formulas that include personal info). Avoid publishing raw blueprints publicly if they include anything confidential or sensitive. If you need to share an example, scrub or replace any real IDs or personal data. Also consider that the JSON might include things like email addresses, default field values, or content from the last run (in `restore` sections). From a security standpoint, **the absence of credentials in the JSON is by design** ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=,Connectors%20or%20Credentials)), so sharing a blueprint is relatively safe in that regard – the main risk is someone seeing your scenario logic or non-secret configuration data. Conversely, if you receive a JSON from someone else, you must insert your own auth. Never assume a blueprint will run out-of-the-box in your account without adding credentials – you wouldn’t want to accidentally push data to someone else’s account even if it did. Make’s import process ensures you review and connect accounts, especially for critical modules like webhooks (you’ll need to configure the webhook address) and other API connections.  

- **Dependencies Between Modules** (Summary): The JSON explicitly manages dependencies through references. An **order dependency** (A before B) is usually implied because B’s mapper uses A. A **data dependency** (A’s output needed by B) is the same thing – captured by that reference. A **service dependency** (module needs an external service) is captured by an account ID in parameters. And a **logic dependency** (run B only if A’s data meets condition) is captured by a filter object. Recognizing these in the JSON helps you not only understand the workflow but also safely modify it. For example, if you remove module A from the JSON, you must also remove or adjust any module that was referencing `A` (in mappers, filters, or feeders), otherwise the imported scenario will have broken mappings. It’s analogous to removing a function in code that other functions were calling. Always search the JSON for the module’s ID you plan to remove or change, to update all occurrences.  

- **Example – Re-authenticating after Import**: Imagine you exported a scenario that sends a Telegram message. In the JSON for the Telegram module, you’d see something like: `"parameters": { "chatId": "@mychannel" }, "mapper": { "text": "{{...}}", "__IMTCONN__": 123456 }`. The `__IMTCONN__`: 123456 would be the Telegram bot connection ID ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,chatId)) ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,false)). If you share this JSON, the recipient will import it, and the Telegram module will reference an ID that doesn’t exist in their account. The module will appear unconfigured – they will need to open it and select their Telegram bot (which might then change the JSON to `"__IMTCONN__": 789012` internally once they pick a valid connection). This is expected. The **blueprint export/import process deliberately omits actual authentication tokens** and requires the user to have appropriate access and re-link accounts. It’s a good security measure to prevent accidental leakage of credentials when sharing workflows. Just be mindful that any manual JSON edits should not try to insert actual tokens; always use the connection references mechanism that Make uses.  

In conclusion, the exported JSON structure of Make.com scenarios provides a complete blueprint of the workflow’s logic and configuration, organized in a hierarchical format. Modules are represented with all their settings and are linked together by ID references (for data flow and execution order) and nested arrays (for branching paths). By examining real examples of these JSON files, one can identify how triggers, actions, filters, and iterators are encoded. While it’s possible to hand-edit or generate these JSON blueprints for advanced purposes, it should be done with care to maintain the integrity of the scenario. And importantly, remember that certain elements like authentication details are handled via references in the JSON – you’ll need to reconnect those when importing, both for functionality and for security ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=,Connectors%20or%20Credentials)). With a solid understanding of this JSON schema, users can confidently export their Make workflows, adjust or version-control them, and re-import or share them, knowing exactly how their scenario is represented under the hood. 

**Sources:** The Make.com community and documentation provide insights into blueprint structure and best practices. The official guide to exporting/importing notes that the `.json` blueprint contains the full scenario (modules, connections, filters) ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=,modules%2C%20connections%2C%20filters%2C%20and%20actions)) and should be reviewed for accuracy. Examples of real blueprint JSON (such as a “Daily Digest” scenario ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=%7B%20,)) ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,))) illustrate the nesting of modules and representation of mappings and filters. Community-contributed blueprints and discussions ([Integromat scenario blueprint to send daily digest with Google Calendar events and today weather to Telegram · GitHub](https://gist.github.com/gelin/27692e97ebbc1f722cb5d62d714af1f5#:~:text=,)) ([Blueprint does not open - Getting Started - Make Community](https://community.make.com/t/blueprint-does-not-open/56806#:~:text=%E2%80%9Cvalues%E2%80%9D%3A%20,Basics%E2%80%9D%2C%20%E2%80%9CspreadsheetId%E2%80%9D%3A%20%E2%80%9C%2F%E2%80%9D%2C%20%E2%80%9CincludesHeaders%E2%80%9D%3A%20true)) have been used to extract real JSON samples, and an Ava Tech blog post offers tips on validating and adjusting JSON blueprints (like swapping connection IDs) before re-use ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=Note%3A%20If%20you%20have%20custom,to%20manually%20update%20each%20module)) ([How to Export and Validate Blueprints in Make](https://www.avatech.nz/post/how-to-export-and-validate-blueprints-in-make#:~:text=,Connectors%20or%20Credentials)). These sources collectively shed light on the JSON format and how to safely work with it.